import inspect
from typing import List
from .db_tmp import db, db_index, tool_name_to_index # db_tmp is to stimulate the real database
from .register_api_tmp import *


def create_inter_api_key(legal_api_name, api_file_path, user):
    """_summary_
    inter_api_key: refers to the 3rd party API key (We call it locally for now, might use it for future server to call them)
    
    Args:
        legal_api_name (_type_): A legal api name is formatted as [PROVIDER NAME]_[ACTION NAME] in upperletters
        api_file_path: [Temporary] Keep the api key in local file
        user: For now, just a placeholder for user information
    Results:
        True, inter_api_key: create the api key successful
        True, None: this api does not need api
        False, None: the request failed
    """
    try:
        provider_name, action_name = legal_api_name.split("_")
    except:
        print("Illegal API name. Please formatted as '[PROVIDER NAME]_[ACTION NAME]' in string")
    
    try:
        
        assert db[provider_name][action_name]["api_key_flg"] != 0
        
        match db[provider_name][action_name]: # The action exists
            case _:
                # For now it is just a stub code for google search
                if legal_api_name == "GOOGLE_SEARCH":
                    inter_api_key = register_api_tmp[legal_api_name]
                    with open(api_file_path, 'w') as f:
                        f.write(f"ACTION_{legal_api_name}_KEY = '{inter_api_key}'\n")
                    print(f"Created a new API key for {legal_api_name} and saved into {api_file_path}")
                    return True, inter_api_key
            
            
            # TODO: Register a API key for developers? [HasBeenDiscussed]
            # TODO: There might be some APIs need to install their own libary mandatory? 
            # TODO: Maybe we can download those library in user local folder?? Just likw how huggingface save checkpoints in user local folders? Or prompt users to install it
            
        
    except Exception as e:
        print(e)
        return False, None
    
    
def definition(tool_list: List) -> List[dict]:
        """_summary_
        Args:
            tool_list: a list of tools to define. Each entry can be:
                - A string representing a pre-defined tool name
                - A dictionary containing a custom tool definition
                - A callable function (not yet implemented)

        This method processes the provided tool list and returns a list of tool definitions.
        For predefined tools (strings), it looks up the definition in the db_index.
        For custom tools (dictionaries), it adds them directly to the list.
        For callable functions, it's going to generate the definition based on the code.

        Raises:
            NotImplementedError: _description_

        Returns:
            List[dict]: _description_
        """

        if not isinstance(tool_list, list): tool_list = [tool_list]
        
        tool_definition_list = []
        for entry in tool_list:
            match entry:
                case str():
                    # If it is a tool name
                    legal_api_name = tool_name_to_index.get(entry, None) # tool_name_to_index is a stub code to stimulate the real database
                    if legal_api_name:
                        # RANDOM IDEA: Add a local mapping between tool name and legal api name?
                        provider_name, action_name = legal_api_name.split("_")
                        tool_definition_list.append(db[provider_name][action_name]['ai_tool_desc'])
                    else:
                        print(f"{entry} is not found in actions library")
                        tool_definition_list.append(entry)
                case dict():
                    tool_definition_list.append(entry)
                case callable():
                    # TODO
                    function_body = inspect.getsource(entry) 
                    # function_body = entry.__code__.co_code.decode()
                    print("An experimental function: get tool description from its code body (also generated by LLM?)")
                    print(function_body)
                    
                    tool_definition_list.append(function_to_json(entry))
                    
                case _:
                    raise ValueError("Unsupported tool type")
        
        return tool_definition_list
    

def function_to_json(func) -> dict:
    """
    https://github.com/openai/swarm?tab=readme-ov-file#examples

    Converts a Python function into a JSON-serializable dictionary
    that describes the function's signature, including its name,
    description, and parameters.

    Args:
        func: The function to be converted.

    Returns:
        A dictionary representing the function's signature in JSON format.
    """
    type_map = {
        str: "string",
        int: "integer",
        float: "number",
        bool: "boolean",
        list: "array",
        dict: "object",
        type(None): "null",
    }

    try:
        signature = inspect.signature(func)
    except ValueError as e:
        raise ValueError(
            f"Failed to get signature for function {func.__name__}: {str(e)}"
        )

    parameters = {}
    for param in signature.parameters.values():
        try:
            param_type = type_map.get(param.annotation, "string")
        except KeyError as e:
            raise KeyError(
                f"Unknown type annotation {param.annotation} for parameter {param.name}: {str(e)}"
            )
        parameters[param.name] = {"type": param_type}

    required = [
        param.name
        for param in signature.parameters.values()
        if param.default == inspect._empty
    ]

    return {
        "type": "function",
        "function": {
            "name": func.__name__,
            "description": func.__doc__ or "",
            "parameters": {
                "type": "object",
                "properties": parameters,
                "required": required,
            },
        },
    }
